# ====================================================
# Main program
curie_demos:
  # run mode
  benchmark_performance: false
  display_disjoint_sets: false
  eliminate_dense_disjoint_sets: false
  check_valid_vertices: false
  preprocess_spars: false
  create_spars: true
  continue_spars: false # even if a file has been saved, randomly sample for more coverage
  run_problems: true

  # run type
  headless: false
  planning_runs: 100
  problem_type: 1 # 0 - random, 1 - imarkers
  auto_run: true # do not wait to move interactive markers
  experience_planner: bolt
  #experience_planner: thunder
  #planning_group_name: both_arms
  planning_group_name: right_arm
  use_task_planning: true  # cartesian hybrid planning
  post_processing: false
  post_processing_interval: 20 # how often (in runs) to adjust the graphs
  seed_random: true
  visualize:
    display_database: false # does not display database as it is built, however
    start_goal_states: false
    interpolated_traj: true
    time_between_plans: 2
    database_every_plan: false
  verbose:
    print_trajectory: false
    verbose: false

# ====================================================
debug_interface:
  autonomous: false
  full_autonomous: false

# ====================================================
sparse_graph:
  save_enabled: true
  super_debug: false # run more checks and tests that slow down speed
  verbose:
    add: false # debug when addVertex() and addEdge() are called
  visualize:
    spars_graph: false
    spars_graph_speed: 0 #.00001 # if 0, does not animate but only single image draw
    database_vertices: true
    database_edges: true
    database_coverage: true # the grey circles around vertices
    quality_path_simp: true # simplification
    astar: true # show node expansions and openings
    astar_speed: 0.01 # how many seconds to wait between each visualization

# ====================================================
sparse_criteria:
  sparse_delta_fraction: 0.1
  dense_delta_fraction: 0.01
  near_sample_points_multiple: 2
  stretch_factor: 5 # 0 means auto set
  discretize_penetration_dist: 0.01 #0.001
  obstacle_clearance: 0.006 #0.0035 # max before gripper piece is in collision
  fourth_criteria_after_failures: 1000 # mode change to 4th criteria after this many failures
  terminate_after_failures: 1000 # total failures, including 4th criteria
  sparse_creation_insertion_order: 1 # 0 - popularity, 1 - default, 2 - random
  percent_max_extent_underestimate: 1.5 # 0 to 1
  use_discretized_samples: true
  use_random_samples: true
  use_check_remove_close_vertices: true # Experimental feature that allows very closeby vertices to be merged with newly added ones
  use_clear_edges_near_vertex: true # When adding a quality vertex, remove nearby edges
  use_original_smoother: false # original is bad
  save_interval: 100 # how often to save during randmo sampling
  verbose:
    added_reason: true # print when adding vertices & edges, and the reason why
    criteria: false
    quality: false
    remove_close: false
  visualize:
    attempted_states: false # show the current sampled state before its added
    connectivity: false # show states in different connected components for connectivity criteria
    quality_criteria: false
    remove_close_vertices: false
    voronoi_diagram: false
    voronoi_diagram_animated: false
    node_popularity: false

# ====================================================
vertex_discretizer:
  verbose:
    verbose: true
    thread: false # output within threading (very verbose)
  visualize:
    grid_generation: false

# ====================================================
task_graph:
  verbose:
    add: false # debug when addVertex() and addEdge() are called
    search: true
    visualize: true
    verbose: true
  visualize:
    task_graph: false
    task_graph_speed: 0.00001 # if 0, does not animate but only single image draw
    database_vertices: true
    database_edges: true
    astar: true # show node expansions and openings
    astar_speed: 0.01 # how many seconds to wait between each visualization

# ====================================================
dense_cache:
  disable_cache: false
  enable_cache_saving: false
  save_every_n_edges: 50000

# ====================================================
bolt_planner:
  verbose:
    verbose: true
  visualize:
    raw_trajectory: true

# ====================================================
bolt:
  visualize:
    raw_trajectory: true

# ====================================================
# for ur5_demo_descartes/src/ur_moveit_plugin.cpp TODO: this is crappy code
arm_prefix: right_

# ====================================================
ur5_descartes_app:
  group_name: right_arm
  tip_link: right_gripper_target
  base_link: right_base_link
  world_frame: world
  trajectory:
    time_delay: 0.1
    foci_distance: 0.07
    radius: 0.097
    num_points: 200
    num_lemniscates: 4
    center: [0.6, -0.2, 0.2]
    seed_pose: [0.0, -1.7, 1.7 , 0.0, 1.5, 0.0]
  visualization:
    min_point_distance: 0.02
  controller_joint_names: [right_shoulder_pan_joint, right_shoulder_lift_joint, right_elbow_joint, right_wrist_1_joint, right_wrist_2_joint, right_wrist_3_joint]

# ====================================================
# Interface for publishing joint/cartesian commands to the low level controllers
execution_interface:
  command_mode: joint_publisher # method for publishing commands from this node to low level controller
  cartesian_command_topic: /hilgendorf/cartesian_controller/cartesian_command # command output from this node
  joint_trajectory_topic: /hilgendorf/cartesian_controller/command # command output from this node
  save_traj_to_file: false # debug mode for creating a CSV for use with Matlab
  save_traj_to_file_path: /home/dave/ros/current/ws_swri/src/trajectory_data/ # debug
  visualize_trajectory_line: false # show in RViz a series of markers visualizing path
  visualize_trajectory_path: false # show in RViz the robot moving on the trajectory path
  check_for_waypoint_jumps: false # ensure that any trajectory that is published does not have huge discontinuties in joint space

# MoveIt Boilerplate Base Functionality
moveit_base:
  joint_state_topic: /hilgendorf/joint_states # location to recieve updates of the robot's pose
  joint_model_group: whole_body # the main planning group to control
  planning_scene_topic: /swri/planning_scene  # topic for communicating the collision obj in the env with other nodes
  rviz:
    markers_topic: /hilgendorf/markers
    robot_state_topic: /hilgendorf/robot_state
    trajectory_topic: /hilgendorf/display_trajectory